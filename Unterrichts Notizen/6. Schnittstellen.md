
**Date:** 12-09-2025
**Author:** Batuhan Seker
**Tags:** #testing #schul-module 
# 6. Schnittstellen

## Test Doubles

**Test Doubles** werden in zwei Hauptkategorien aufgeteilt:
- Mock (mock, spy)
- Stub (stub, dummy, fake)

Beim Testen soll sie alle Abhängigkeiten einer Klasse oder Funktion eliminieren.

![](./x_ressources/2025-09-12/image/image.png)
- Ein **Mock** wartet darauf, von der zu testenden Klasse (A) aufgerufen zu werden.
    - Vielleicht hat sie mehrere Methoden, die sie erwartet und die A aufrufen sollte.
- Sie stellt sicher, dass sie auf genau die richtige Weise kontaktiert wurde.
    - Wenn A mit B so interagiert, wie es sein sollte, ist der Test erfolgreich.

![](./x_ressources/2025-09-12/image/image-2.png)
- Ein **Stub** gibt Daten aus, die an die zu testende Klasse/das zu testende Objekt gehen.
- Der Unit-Test überprüft direkt die zu testende Klasse, um sicherzustellen, dass er das richtige Ergebnis liefert, wenn er mit diesen Daten gefüttert wird
![](./x_ressources/2025-09-12/image/image-3.png)

### Lifecycle

| Stubs                                                                              | Mocks                                                                                                                 |
| ---------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------- |
| 1. Setup - Bereiten Sie das zu testende Objekt und seine Stubs-Kollaborateure vor. | 1. Daten einrichten - Bereiten Sie das zu testende Objekt vor.                                                        |
| 2. Anwenden - Testen Sie die Funktionalität.                                       | 2. **Setup expectations** - Bereiten Sie die Erwartungen in der Attrappe vor, die vom primären Objekt verwendet wird. |
| 3. Verify state - Verwenden Sie Asserts, um den Zustand des Objekts zu überprüfen. | 3. Anwenden - Testen Sie die Funktionalität.                                                                          |
| 4. Teardown - Aufräumen der Ressourcen.                                            | 4. **Verify expectations** - Überprüfen Sie, ob die richtigen Methoden im Mock aufgerufen wurden.                     |
|                                                                                    | 5. Verify state - Verwenden Sie Asserts, um den Zustand des Objekts zu überprüfen.                                    |
|                                                                                    | 6. Teardown - Aufräumen der Ressourcen.                                                                               |
|                                                                                    |                                                                                                                       |
## Mock, Spy Stub, Fake, Dummy

![](./x_ressources/2025-09-12/image/image-4.png)

---

### Mock
Mocks sind Objekte, denen man sagen kann, was sie zu empfangen erwarten. Sie werden verwendet, um das Verhalten
zwischen dem zu testenden System und seinen Kollaborateuren zu verifizieren.
Sie setzen Ihre Erwartungen, rufen die Methode des SUT auf und überprüfen, ob die Methode am Ende aufgerufen wurde.
### Spy
Stellen Sie sich einen Spy wie jemanden vor, der sich in Ihren SUT eingeschleust hat und jede seiner Bewegungen
aufzeichnet, genau wie ein echter Spion. Im Gegensatz zu Mocks schweigt der Spion und es liegt an Ihnen, anhand der
Daten, die er liefert, Aussagen zu treffen.
Sie verwenden Spione, wenn Sie sich nicht sicher sind, was Ihr SUT von Ihrem Mitarbeiter abrufen wird, also zeichnen Sie alles auf und stellen fest, ob der Spion die gewünschten Daten abgerufen hat.
### Dummy
Dummy-Objekte sind sehr simpel. Ein Dummy ist z.B. nur ein Objekt, das Sie übergeben, um einen Konstruktor zu initialisieren.
Das kann etwas Einfaches sein wie z.B. einen 'null'-Wert als Parameter mitgegeben. Es wird keine Methode implementiert.
### Stub
Ein Stub ist ein Objekt, das vordefinierte Daten enthält und diese zur Beantwortung von Aufrufen während der Tests
verwendet. Es wird verwendet, wenn wir keine Objekte einbeziehen können oder wollen, die mit echten Daten antworten
würden oder unerwünschte Nebeneffekte hätten.
Ein Beispiel ist ein Objekt, das Daten aus der Datenbank abrufen muss, um auf einen Methodenaufruf zu reagieren.
Anstelle des echten Objekts haben wir einen Stub eingeführt und definiert, welche Daten zurückgegeben werden sollen. Die
Daten sind meistens sehr simpel und hardcoded.
### Fake
Fakes sind Objekte, die funktionierende Implementierungen haben, die aber nicht mit dem Produktionscode übereinstimmen.
Stub und Fakes sind sehr ähnlich. Fakes sind jedoch naher an einer realen Implementierung als ein Stub. Normalerweise
nehmen sie eine Abkürzung und haben
eine vereinfachte Version des Produktionscodes.
Ein Beispiel für eine solche Abkürzung ist eine In-Memory-Implementierung von Data Access Object oder Repository. Diese
Fake-Implementierung greift nicht auf eine Datenbank zu, sondern verwendet eine einfache Sammlung zum Speichern von
Daten (zum Beispiel gefeedet aus einem CSV file). So können wir Integrationstests von Diensten durchführen, ohne eine
Datenbank zu starten und zeitaufwändige Anfragen durchzuführen.

---
## Mockito - alles in einem

Nicht nur Mockito, sondern die meisten Mocking-Frameworks haben dieses Enten-Syndrom, bei dem sie mehrere Dinge tun
können: eine Ente kann schwimmen, fliegen und laufen. Diese Frameworks arbeiten mit Dummies, Mocks, Spys und Stubs.
* Lesen Sie das [Mockito Tutorial](https://www.vogella.com/tutorials/Mockito/article.html) bis und mit dem 9. Kapitel
## Sonstige Use Cases
Zusätzlich gibt es auch Frameworks, welche einen HTTP mock server initialisieren und so einem ermöglichen API's zu mocken
und HTTP Responses zu stubben. Eine Variante dafür wäre z.B. [WireMock](https://wiremock.org/)
## Source
* https://stackoverflow.com/questions/3459287/whats-the-difference-between-a-mock-stub
* https://stackoverflow.com/questions/346372/whats-the-difference-between-faking-mocking-and-stubbing
* https://methodpoet.com/stub-vs-mock/
* https://blog.pragmatists.com/test-doubles-fakes-mocks-and-stubs-1a7491dfa3da
* https://www.javacodegeeks.com/2019/04/introduction-to-test-doubles.html

---
## 1. Dummy vs Stub vs Fake vs Mock vs Spy

These are often mixed up. They all fall under **test doubles**: objects you use in tests instead of real ones.
- **Dummy**: Object only used to fill parameter lists. Not used at all.
- **Stub**: Provides predefined answers to calls. Does not record usage.
- **Fake**: Has working but simplified implementation. Often in-memory.
- **Mock**: A stub plus the ability to verify interactions. Checks whether certain methods were called.
- **Spy**: Wraps a real object but lets you monitor and override parts of it.

---

## 2. Mockito in practice

### Create a mock

```java
@Mock
AddressRepository repo;
```

### Stub behavior

```java
when(repo.findById(1)).thenReturn(Optional.of(new Address(1,"Max","Muster","079", new Date())));
```

This is **stubbing**: you tell the mock what to return.

### Verify interaction


```java
service.save(address);
verify(repo).save(address);
```

This is **mock verification**: you check _how_ the code under test used its collaborator.

---

## 3. Example differences

### Stub only

```java
class StubRepository implements AddressRepository {
    @Override
    public Optional<Address> findById(int id) {
        return Optional.of(new Address(id, "Stub", "User", "000", new Date()));
    }
    // other methods empty
}
```

- Works without Mockito.
- Provides predictable data.
- No checking whether it was used correctly.

### Fake

```java
class InMemoryAddressRepository implements AddressRepository {
    private Map<Integer, Address> store = new HashMap<>();
    @Override public Address save(Address a) { store.put(a.getId(), a); return a; }
    @Override public Optional<Address> findById(int id) { return Optional.ofNullable(store.get(id)); }
    @Override public List<Address> findAll() { return new ArrayList<>(store.values()); }
}
```

- Can be used in integration-like tests.
- Still no database dependency.
### Mock (Mockito)

```java
@Mock AddressRepository repo;
@InjectMocks AddressService service;

@Test
void testSaveDelegates() {
    Address a = new Address(1,"A","B","123", new Date());
    when(repo.save(a)).thenReturn(a); // stub
    service.save(a);
    verify(repo).save(a); // mock verification
}
```

- Gives full control over behavior and interaction verification.

### Spy

```java
@Test
void testSpy() {
    List<String> list = new ArrayList<>();
    List<String> spyList = spy(list);

    spyList.add("hello");
    verify(spyList).add("hello");   // check interaction
    assertEquals(1, spyList.size()); // real method executed
}
```

- Mixes real behavior with verifications.

---

## 4. When to use what?

- **Dummy**: Rare, only when method signature forces you.
- **Stub**: When you need specific return values but do not care how often it was called.
- **Fake**: When you want a fast but working implementation (e.g., replace DB with `Map`). Good for integration tests.
- **Mock**: When you care about _interactions_ with dependencies. Most common in Spring service tests.
- **Spy**: When you want to partially test a real object but still verify calls.

---

## 5. In your project

- **Service tests**: use **mocks** for `AddressRepository`. That way you avoid H2 and still check that the service sorts and delegates.
- **Comparator tests**: no mocks needed, just real objects.
- **Controller tests**: mock the **service** with `@MockBean`. You only test web layer + JSON mapping.
- **Repository tests** (optional): you can use **fakes** (`InMemoryAddressRepository`) or Spring’s `@DataJpaTest` with H2.